const { GoogleSpreadsheet } = require('google-spreadsheet');
const { JWT } = require('google-auth-library');
const axios = require('axios');
require('dotenv').config();

const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const GOOGLE_SHEETS_ID = process.env.GOOGLE_SHEETS_ID;
const GOOGLE_SHEETS_TOPICS_ID = process.env.GOOGLE_SHEETS_ID;
const SERVICE_ACCOUNT_EMAIL = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL;
const PRIVATE_KEY = process.env.GOOGLE_PRIVATE_KEY.replace(/\\n/g, '\n');

const GPT_MODEL = "gpt-4o";
const MAX_ITERATIONS = 3;
const language = '◊¢◊ë◊®◊ô◊™';
const platform = '◊§◊ô◊ô◊°◊ë◊ï◊ß';
const businessName = '◊§◊©◊ï◊ò◊ï◊û◊¶◊ô◊î';

/**
 * Removes asterisks from GPT output
 */
function removeAsterisks(text) {
    return text.replace(/\*/g, '');
}

async function fetchTopicsFromGoogleSheets() {
    const serviceAccountAuth = new JWT({
        email: SERVICE_ACCOUNT_EMAIL,
        key: PRIVATE_KEY,
        scopes: ['https://www.googleapis.com/auth/spreadsheets'],
    });

    const doc = new GoogleSpreadsheet(GOOGLE_SHEETS_TOPICS_ID, serviceAccountAuth);
    try {
        await doc.loadInfo();
        const sheet = doc.sheetsByIndex[0];
        const rows = await sheet.getRows();
        
        return rows
            .filter(row => row["Used"] === "FALSE")
            .map(row => row["Topic"])
            .filter(Boolean);
    } catch (error) {
        console.error("‚ùå Error fetching topics from Google Sheets:", error);
        return [];
    }
}


/**
 * Generates content ready for publication
 */
async function generateContent(topic, lastPost, lastFeedback) {
    let prompt = `◊ê◊™◊î ◊ô◊ï◊¶◊® ◊™◊ï◊õ◊ü ◊û◊ß◊¶◊ï◊¢◊ô ◊©◊û◊™◊û◊ó◊î ◊ë◊õ◊™◊ô◊ë◊î ◊ú◊§◊ô◊ô◊°◊ë◊ï◊ß ◊¢◊ë◊ï◊® ◊¢◊°◊ß◊ô◊ù ◊ß◊ò◊†◊ô◊ù ◊ï◊ë◊ô◊†◊ï◊†◊ô◊ô◊ù. ◊î◊™◊ï◊õ◊ü ◊¶◊®◊ô◊ö ◊ú◊î◊ô◊ï◊™ ◊û◊ï◊õ◊ü ◊ú◊§◊®◊°◊ï◊ù, ◊ë◊ú◊ô ◊õ◊ï◊™◊®◊ï◊™, ◊ë◊ú◊ô ◊®◊©◊ô◊û◊ï◊™, ◊ë◊ú◊ô ◊õ◊ï◊õ◊ë◊ô◊ï◊™ ◊ï◊ë◊ú◊ô ◊ì◊ï◊í◊û◊ê◊ï◊™ ◊©◊ú◊ê ◊ß◊®◊ï. ◊î◊ò◊ß◊°◊ò ◊¶◊®◊ô◊ö ◊ú◊î◊ô◊ï◊™ ◊ß◊ú◊ô◊ú, ◊ë◊®◊ï◊® ◊ï◊û◊†◊ô◊¢ ◊ú◊§◊¢◊ï◊ú◊î. ◊™◊©◊ú◊ë ◊ê◊ô◊û◊ï◊í'◊ô◊ù ◊ë◊¶◊ï◊®◊î ◊ò◊ë◊¢◊ô◊™, ◊õ◊ê◊ô◊ú◊ï ◊†◊õ◊™◊ë ◊¢◊ú ◊ô◊ì◊ô ◊û◊©◊ï◊ï◊ß ◊©◊û◊õ◊ô◊® ◊ê◊™ ◊î◊ß◊î◊ú. ◊ê◊ù ◊ô◊© ◊¶◊ï◊®◊ö ◊ú◊¶◊ô◊ô◊ü ◊ê◊™ ◊©◊ù ◊î◊¢◊°◊ß, ◊î◊©◊™◊û◊© ◊ë◊©◊ù "${businessName}". ◊ê◊ô◊ü ◊ú◊õ◊ú◊ï◊ú ◊û◊°◊§◊®◊ô ◊ò◊ú◊§◊ï◊ü ◊ê◊ï ◊õ◊™◊ï◊ë◊ï◊™ ◊û◊ô◊ô◊ú ◊ë◊§◊ï◊°◊ò◊ô◊ù. ◊ê◊ô◊ü ◊ú◊î◊©◊™◊û◊© ◊ë◊õ◊ï◊õ◊ë◊ô◊ï◊™ ◊ë◊ò◊ß◊°◊ò.`;

    if (lastPost && lastFeedback) {
        prompt += `\n\n◊î◊†◊î ◊î◊í◊®◊°◊î ◊î◊ß◊ï◊ì◊û◊™ ◊©◊ú ◊î◊§◊ï◊°◊ò ◊ô◊ó◊ì ◊¢◊ù ◊î◊û◊©◊ï◊ë ◊©◊†◊ô◊™◊ü ◊¢◊ú◊ô◊î:\n\n◊í◊®◊°◊î ◊ß◊ï◊ì◊û◊™:\n${lastPost}\n\n◊û◊©◊ï◊ë:\n${lastFeedback}\n\n◊õ◊™◊ï◊ë ◊û◊ó◊ì◊© ◊ê◊™ ◊î◊§◊ï◊°◊ò ◊¢◊ú ◊î◊†◊ï◊©◊ê: ${topic} ◊™◊ï◊ö ◊©◊ô◊§◊ï◊® ◊î◊û◊ë◊†◊î ◊ï◊î◊©◊§◊î ◊ë◊î◊™◊ê◊ù ◊ú◊û◊©◊ï◊ë.`;
    } else {
        prompt += `\n\n◊õ◊™◊ï◊ë ◊§◊ï◊°◊ò ◊ó◊ì◊© ◊¢◊ú ◊î◊†◊ï◊©◊ê: ${topic}.`;
    }

    const response = await axios.post("https://api.openai.com/v1/chat/completions", {
        model: GPT_MODEL,
        messages: [{ role: "system", content: prompt }]
    }, {
        headers: { "Authorization": `Bearer ${OPENAI_API_KEY}` }
    });

    return removeAsterisks(response.data.choices[0].message.content);
}

/**
 * Reviews the generated content and provides scores with feedback.
 */
async function reviewContent(content) {
    const response = await axios.post("https://api.openai.com/v1/chat/completions", {
        model: GPT_MODEL,
        messages: [
            { role: "system", content: `You are a professional content reviewer.
            Evaluate the following post based on the criteria below, giving a score from 1 to 10:
            - Clarity & Readability
            - Engagement & Relevance
            - Brand Consistency
            - Practical Value
            - SEO & Formatting
            - Call-to-Action (CTA)
            7. The language should be in ${language} !
            
            If any category scores below 9, provide detailed feedback for improvement.` },
            { role: "user", content: `Review the following post and provide category-wise scores: ${content}` }
        ]
    }, {
        headers: { "Authorization": `Bearer ${OPENAI_API_KEY}` }
    });

    return removeAsterisks(response.data.choices[0].message.content);
}

/**
 * Improves the content based on the provided feedback.
 */
async function improveContent(content, review) {
    const response = await axios.post("https://api.openai.com/v1/chat/completions", {
        model: GPT_MODEL,
        thread_id: threadId,  // ◊î◊ï◊°◊§◊™ thread_id
        messages: [
            { role: "system", content: `You are a senior content creator and social media manager. I‚Äôm sending you a post to review and edit. Please focus on the following points:Ensure the post follows marketing principles.The post is for a business named ◊§◊©◊ï◊ò◊ï◊û◊¶◊ô◊î, which focuses on automation process development for businesses.The language should be casual, friendly, and easy to understand.Integrate emojis in the post.The post should be between 10-15 lines, so it‚Äôs easy for people to read.Do not include any success stories of our business in the post.Please make the necessary edits and ensure the content is engaging and aligns with these guidelines. Improve the post based on the provided feedback.` },
            { role: "user", content: `Improve the following post based on the feedback:\n\n**Current content:**\n${content}\n\n**Feedback:**\n${review}` }
        ]
    }, {
        headers: { "Authorization": `Bearer ${OPENAI_API_KEY}` }
    });

    return removeAsterisks(response.data.choices[0].message.content);
}

/**
 * Checks if the content is approved (all scores are 9 or higher).
 */
function isContentApproved(review) {
    const scores = review.match(/\d+/g)?.map(Number) || [];
    return scores.length > 0 && scores.every(score => score >= 9);
}

/**
 * Saves data to Google Sheets.
 */
async function saveToGoogleSheets(topic, firstDraft, finalContent, initialFeedback, finalScores, iterations) {
    const serviceAccountAuth = new JWT({
        email: SERVICE_ACCOUNT_EMAIL,
        key: PRIVATE_KEY,
        scopes: ['https://www.googleapis.com/auth/spreadsheets'],
    });

    const doc = new GoogleSpreadsheet(GOOGLE_SHEETS_ID, serviceAccountAuth);

    try {
        await doc.loadInfo();
        const sheet = doc.sheetsByIndex[0];

        await sheet.addRow({
            "Post Topic": topic,
            "Initial Draft": firstDraft,
            "Final Version": finalContent,
            "First Iteration Feedback": initialFeedback,
            "Final Scores": finalScores,
            "Iteration Count": iterations,
            "Creation Date": new Date().toLocaleDateString(),
            "Approval Date": new Date().toLocaleDateString()
        });

        console.log("‚úÖ Post saved to Google Sheets!");
    } catch (error) {
        console.error("‚ùå Error saving data to Google Sheets:", error);
    }
}

/**
 * Iteratively improves content up to a maximum of three iterations.
 */
async function iterativeImprovement(topic, lastPost = null, lastFeedback = null) {
    let firstDraft = await generateContent(topic, lastPost, lastFeedback);
    let review = await reviewContent(firstDraft);
    let initialFeedback = review;
    let iteration = 1;
    let finalContent = firstDraft;

    while (!isContentApproved(review) && iteration < MAX_ITERATIONS) {
        console.log(`üîÑ Iteration ${iteration} - Improving content`);
        finalContent = await improveContent(finalContent, review);
        review = await reviewContent(finalContent);
        iteration++;
        if (iteration == MAX_ITERATIONS) {
            console.log("‚úÖ Maximum iterations reached!");
        }
    }

    console.log("‚úÖ Content approved");

    await saveToGoogleSheets(topic, firstDraft, finalContent, initialFeedback, review, iteration);
    return finalContent;
}

/**
 * Fetches the last post and its feedback from Google Sheets.
 */
async function getLastPostFromGoogleSheets() {
    const serviceAccountAuth = new JWT({
        email: SERVICE_ACCOUNT_EMAIL,
        key: PRIVATE_KEY,
        scopes: ['https://www.googleapis.com/auth/spreadsheets'],
    });

    const doc = new GoogleSpreadsheet(GOOGLE_SHEETS_ID, serviceAccountAuth);

    try {
        await doc.loadInfo();
        const sheet = doc.sheetsByIndex[0];
        const rows = await sheet.getRows();

        if (rows.length === 0) {
            console.log("‚ö†Ô∏è No previous posts found in Google Sheets.");
            return { lastPost: null, lastFeedback: null };
        }

        // Get the last row
        const lastRow = rows[rows.length - 1];

        // Print available keys and raw data
        // console.log("üîç Available raw data in last row:", lastRow._rawData);
        // console.log("üìë Column headers:", lastRow._worksheet.headerValues);

        // Get column headers and their respective values from _rawData
        const headers = lastRow._worksheet.headerValues;
        const values = lastRow._rawData;

        // Ensure headers exist
        if (!headers || !values || headers.length !== values.length) {
            console.log("‚ö†Ô∏è Column headers and values do not match.");
            return { lastPost: null, lastFeedback: null };
        }

        // Map column names to values
        const rowData = Object.fromEntries(headers.map((key, index) => [key, values[index]]));

        // console.log("üìÑ Mapped row data:", rowData);

        return {
            lastPost: rowData["Final Version"]?.trim() || null,
            lastFeedback: rowData["First Iteration Feedback"]?.trim() || null
        };
    } catch (error) {
        console.error("‚ùå Error fetching data from Google Sheets:", error);
        return { lastPost: null, lastFeedback: null };
    }
}

async function processTopics() {
    const topics = await fetchTopicsFromGoogleSheets();
    if (topics.length === 0) {
        console.log("‚ö†Ô∏è No topics found.");
        return;
    }

    for (const topic of topics) {
        console.log(`üöÄ Processing topic: ${topic}`);
        const { lastPost, lastFeedback } = await getLastPostFromGoogleSheets();
        const finalContent = await iterativeImprovement(topic, lastPost, lastFeedback);
        console.log(`üìå Final content for '${topic}':`, finalContent);
    }
}

/**
 * Executes the system with input from the last post.
 */
(async () => {
    processTopics();


    // const topic = "◊ò◊¢◊ï◊ô◊ï◊™ ◊†◊§◊ï◊¶◊ï◊™ ◊ë◊î◊ò◊û◊¢◊™ ◊ê◊ï◊ò◊ï◊û◊¶◊ô◊î ◊ï◊ê◊ô◊ö ◊ú◊î◊ô◊û◊†◊¢ ◊û◊î◊ü";

    // // Fetch last post and feedback from Google Sheets
    // const { lastPost, lastFeedback } = await getLastPostFromGoogleSheets();

    // if (lastPost) {
    //     console.log("üìÑ Found previous post! Using it as a base for improvement:");
    //     // console.log(`üîπ Previous Version:\n${lastPost}`);
    //     console.log(`üí° Reviewer Feedback:\n${lastFeedback}\n\n`);
    // } else {
    //     console.log("üÜï No previous post found. Creating a new one.");
    // }

    // // Start the improvement process with adjusted input
    // const finalContent = await iterativeImprovement(topic, lastPost, lastFeedback);
    // console.log("üìå Final Approved Content:", finalContent);
})();
